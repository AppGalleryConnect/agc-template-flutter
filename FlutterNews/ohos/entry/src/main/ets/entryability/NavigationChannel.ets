/**
 * Flutter å’Œé¸¿è’™åŸç”Ÿé¡µé¢äº’ç›¸è·³è½¬çš„é€šé“
 */
import { MethodChannel, MethodCall, MethodResult, FlutterPlugin, FlutterPluginBinding } from '@ohos/flutter_ohos';
import { promptAction, router } from '@kit.ArkUI';
import { scanBarcode, scanCore } from '@kit.ScanKit';
import { emitter, BusinessError } from '@kit.BasicServicesKit';
import geoLocationManager from '@ohos.geoLocationManager';
import { LogUtil } from '@pura/harmony-utils';
import { abilityAccessCtrl, bundleManager, common, Permissions} from "@kit.AbilityKit"

const TAG = '[NavigationChannel]';


export class NavigationChannel implements FlutterPlugin {
  private channel?: MethodChannel;
  private context: common.UIAbilityContext;

  constructor(context: common.UIAbilityContext) {
    this.context = context;
  }

  getUniqueClassName(): string {
    return 'NavigationChannel';
  }

  onAttachedToEngine(binding: FlutterPluginBinding): void {
    console.info(TAG, 'ğŸš€ å¼€å§‹æ³¨å†Œ NavigationChannel');

    this.channel = new MethodChannel(
      binding.getBinaryMessenger(),
      'com.news.flutter/navigation'
    );

    this.channel.setMethodCallHandler({
      onMethodCall: (call: MethodCall, result: MethodResult): void => {
        console.info(TAG, `âš¡ æ”¶åˆ°æ–¹æ³•è°ƒç”¨: ${call.method}`);
        this.handleMethodCall(call, result);
      }
    });

    console.info(TAG, 'âœ… NavigationChannel æ³¨å†ŒæˆåŠŸ');
  }

  onDetachedFromEngine(binding: FlutterPluginBinding): void {
    if (this.channel) {
      this.channel.setMethodCallHandler(null);
    }
  }

  /**
   * å¤„ç† Flutter çš„æ–¹æ³•è°ƒç”¨
   */
  private handleMethodCall(call: MethodCall, result: MethodResult): void {
    console.info(TAG, `å¤„ç†æ–¹æ³•: ${call.method}`);
    console.info(TAG, `å¤„ç†å‚æ•°: ${call.args}`);

    switch (call.method) {
      case 'pushNativePage':
        this.pushNativePage(call.args, result);
        break;
      case 'popNativePage':
        this.popNativePage(result);
        break;
      case 'scan':
        this.scan(result);
        break;
      case 'location':
        this.location(result);
        break;
      case 'share':
        const argsMap = call.args as Map<string, Object>;
        const paramsRaw = argsMap.get('params');
        let params: Record<string, Object> = {};
        if (paramsRaw) {
          if (paramsRaw instanceof Map) {
            console.info(TAG, `params æ˜¯ Mapï¼Œè½¬æ¢ä¸­...`);
            const paramsMap = paramsRaw as Map<string, Object>;
            paramsMap.forEach((value: Object, key: string) => {
              params[key] = value;
            });
          } else {
            params = paramsRaw as Record<string, Object>;
          }
        }
        let event: emitter.InnerEvent = {
          eventId: 10000,
          priority: emitter.EventPriority.IMMEDIATE,
        };

        let eventData: emitter.EventData = {
          data: params,
        };
        emitter.emit(event, eventData);
        break;
      case 'wxShare':
        let wxEvent: emitter.InnerEvent = {
          eventId: 10001,
          priority: emitter.EventPriority.IMMEDIATE,
        };

        let wxEventData: emitter.EventData = {
          data: {
            state: '10001',
          },
        };
        emitter.emit(wxEvent, wxEventData);
        break;
      case 'AInews':
        let AIEvent: emitter.InnerEvent = {
          eventId: 10003,
          priority: emitter.EventPriority.IMMEDIATE,
        };

        let AIEventData: emitter.EventData = {
          data: {
            state: '10003',
            params: call.args,
          },
        };
        emitter.emit(AIEvent, AIEventData);
        break;
      case 'FoldVideo':
        let FoldEvent: emitter.InnerEvent = {
          eventId: 10009,
          priority: emitter.EventPriority.IMMEDIATE,
        };

        let FoldEventData: emitter.EventData = {
          data: {
            state: '10009',
            params: call.args,
          },
        };
        emitter.emit(FoldEvent, FoldEventData);
        break;
      default:
        console.warn(TAG, `æœªå®ç°çš„æ–¹æ³•: ${call.method}`);
        result.notImplemented();
        break;
    }
  }

  /**
   * è·³è½¬åˆ°é¸¿è’™åŸç”Ÿé¡µé¢
   */
  private pushNativePage(args: Object, result: MethodResult): void {
    try {

      // args æ˜¯ä¸€ä¸ª Map å¯¹è±¡ï¼Œä½¿ç”¨ Map çš„ API è®¿é—®
      const argsMap = args as Map<string, Object>;

      // ä½¿ç”¨ Map.get() æ–¹æ³•è·å–å€¼
      const pageName = argsMap.get('pageName') as string;
      const paramsRaw = argsMap.get('params');


      // å°† params è½¬æ¢ä¸ºæ™®é€šå¯¹è±¡
      let params: Record<string, Object> = {};

      if (paramsRaw) {
        // å¦‚æœ params ä¹Ÿæ˜¯ Mapï¼Œéœ€è¦è½¬æ¢
        if (paramsRaw instanceof Map) {
          console.info(TAG, `params æ˜¯ Mapï¼Œè½¬æ¢ä¸­...`);
          const paramsMap = paramsRaw as Map<string, Object>;
          paramsMap.forEach((value: Object, key: string) => {
            params[key] = value;
          });
        } else {
          // å¦‚æœæ˜¯æ™®é€šå¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨
          params = paramsRaw as Record<string, Object>;
        }
      }

      // ç›´æ¥ä½¿ç”¨ router.pushUrl è·³è½¬
      const pageUrl = `pages/${pageName}`;

      router.pushUrl({
        url: pageUrl,
        params: params
      }).then(() => {
        console.info(TAG, `âœ… è·³è½¬æˆåŠŸ: ${pageName}`);
        result.success(true);
      }).catch((err: Error) => {
        console.error(TAG, `âŒ router.pushUrl å¤±è´¥: ${err.message}`);
        result.success(true);
      });

    } catch (err) {
      const error = err as Error;
      console.error(TAG, `å¤„ç†å¼‚å¸¸: ${error.message}`);
      result.error('ERROR', error.message, null);
    }
  }

  /**
   * è¿”å›ä¸Šä¸€é¡µ
   */
  private popNativePage(result: MethodResult): void {
    try {
      console.info(TAG, 'ğŸ”™ è¯·æ±‚è¿”å›ä¸Šä¸€é¡µ');

      this.context.eventHub.emit('EVENT_POP_PAGE', {});

      console.info(TAG, 'âœ… è¿”å›äº‹ä»¶å·²å‘é€');
      result.success(true);
    } catch (err) {
      const error = err as Error;
      console.error(TAG, `è¿”å›å¤±è´¥: ${error.message}`);
      result.error('POP_ERROR', error.message, null);
    }
  }

  async location(scanResult: MethodResult) {
    this.checkPermissions(['ohos.permission.LOCATION', 'ohos.permission.APPROXIMATELY_LOCATION']).then(() => {
      geoLocationManager.getCurrentLocation().then(async location => {
        let reverseGeocodeRequest: geoLocationManager.ReverseGeoCodeRequest = {
          'latitude': location.latitude,
          'longitude': location.longitude,
          'maxItems': 1
        };
          const result = await geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest);
          if (result.length > 0) {
            const firstAddress: geoLocationManager.GeoAddress = result[0];
            const city: string = firstAddress.locality || ''; // åŸå¸‚
            console.log(TAG, 'è·å–åœ°å€æˆåŠŸï¼š' + JSON.stringify(firstAddress));
            scanResult.success({
              city: city,
            });
          }
      }).catch((err: BusinessError) => {
        LogUtil.error(TAG, 'getCurrentLocation catch err: ' + JSON.stringify(err))
      })
    }).catch((err: BusinessError) => {
      // LogUtil.error
      LogUtil.error(TAG, 'getCurrentLocation catch err: ' + JSON.stringify(err))
    })

  }

  /**
   * æ ¡éªŒåº”ç”¨æ˜¯å¦è¢«æˆäºˆå®šä½æƒé™
   * @returns
   */
  async checkPermissions(permissions: Permissions[]): Promise<void> {
    try {
      const result = permissions.every((permission) => {
        let grantStatus: abilityAccessCtrl.GrantStatus = this.checkAccessToken(permission)
        return grantStatus === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED
      })
      if (!result) {
        await this.requestPermissions(permissions)
      }
    } catch (error) {
      LogUtil.error(TAG, `checkPermissions error` + JSON.stringify(error))
    }
  }

  /**
   * å¦‚æœæ²¡æœ‰è¢«æˆäºˆå®šä½æƒé™ï¼ŒåŠ¨æ€å‘ç”¨æˆ·ç”³è¯·æˆæƒ
   */
  async requestPermissions(permissions: Permissions[]): Promise<void> {
    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager()
    try {
      await atManager.requestPermissionsFromUser(this.context, permissions)
      LogUtil.info(TAG, 'requestPermissions LOCATION & APPROXIMATELY_LOCATION success')
    } catch (error) {
      LogUtil.error(TAG, 'requestPermissions error = %{public}s', JSON.stringify(error))
    }
  }

  /**
   * @param æ£€æŸ¥è®¿é—®ä»¤ç‰Œ
   * @returns
   */
  checkAccessToken(permission: Permissions): abilityAccessCtrl.GrantStatus {
    let atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager()
    let grantStatus: abilityAccessCtrl.GrantStatus = abilityAccessCtrl.GrantStatus.PERMISSION_DENIED
    // è·å–åº”ç”¨ç¨‹åºçš„accessTokenID
    let tokenId: number = 0
    let bundleInfo: bundleManager.BundleInfo =
      bundleManager.getBundleInfoForSelfSync(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION)
    let appInfo: bundleManager.ApplicationInfo = bundleInfo.appInfo
    tokenId = appInfo.accessTokenId
    // æ ¡éªŒåº”ç”¨æ˜¯å¦è¢«æˆäºˆæƒé™
    grantStatus = atManager.checkAccessTokenSync(tokenId, permission)
    return grantStatus
  }

  private scan(scanResult: MethodResult): void {
    // å®šä¹‰æ‰«ç å‚æ•°options
    let options: scanBarcode.ScanOptions = {
      scanTypes: [scanCore.ScanType.ALL],
      enableMultiMode: true,
      enableAlbum: true,
    };
    try {
      // å¯è°ƒç”¨getContextæ¥å£è·å–å½“å‰é¡µé¢å…³è”çš„UIAbilityContext
      scanBarcode.startScanForResult(getContext(this), options).then((result: scanBarcode.ScanResult) => {
        // è§£æç å€¼ç»“æœè·³è½¬åº”ç”¨æœåŠ¡é¡µ
        let resultParams: Record<string, string> = JSON.parse(result.originalValue)
        if (!resultParams?.articleId) {
          promptAction.showToast({ message: 'æ‰«ç é”™è¯¯ï¼Œä»…æ”¯æŒæ¨¡æ¿å†…æ–‡ç« æµ·æŠ¥ç”Ÿæˆçš„äºŒç»´ç ' })
          return
        }
        let routerParams = {
          'id': resultParams?.articleId,
        } as Record<string, string>
        // RouterToNews.routerToNewsById(routerParams.id)
        scanResult.success(routerParams.id);
      }).catch((error: BusinessError) => {
        let message: string = ''
        if (error.code === 1000500002) {
          // ç”¨æˆ·å–æ¶ˆæ‰«ç 
          message = 'å–æ¶ˆæ‰«ç '
        } else {
          message = 'æ‰«ç é”™è¯¯'
        }
        promptAction.showToast({ message: message })
      });
    } catch (error) {
      promptAction.showToast({ message: 'æ‰«ç é”™è¯¯' })
    }
  }
}

